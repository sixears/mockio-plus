module MockIO.Process
  ( CmdRW(..), (¬°), Íô©, Íô´
  , doProc, doProc', system, system', systemx, systemx', sys, sys', sysN, sysS )
where

import Base1T hiding ( toList )

-- base --------------------------------

import Data.Function  ( flip )
import Data.List      ( sortOn )
import Data.Maybe     ( fromMaybe )
import GHC.Exts       ( IsList( toList ) )

-- env-plus ----------------------------

import Env        ( getEnvironment )

-- fpath -------------------------------

import FPath.Error.FPathError  ( AsFPathError )

-- lens --------------------------------

import Control.Lens.Getter  ( view )

-- log-plus ----------------------------

import Log  ( Log, logIO )

-- logging-effect ----------------------

import Control.Monad.Log  ( MonadLog, Severity )

-- mockio ------------------------------

import MockIO.DoMock  ( DoMock( DoMock ), HasDoMock )

-- mockio-log --------------------------

import MockIO.IOClass  ( HasIOClass( ioClass ) )
import MockIO.Log      ( MockIOClass, doMock, logResult )

-- monadio-plus ------------------------

import MonadIO.Error.CreateProcError  ( AsCreateProcError )
import MonadIO.Error.ProcExitError    ( AsProcExitError )
import MonadIO.File                   ( devnull )
import MonadIO.NamedHandle            ( stdin )
import MonadIO.Process                ( getPid', procWait, throwExit, throwSig')
import MonadIO.Process.CmdSpec        ( CmdSpec, env )
import MonadIO.Process.ExitInfo       ( ExitInfo, exitInfo )
import MonadIO.Process.ExitStatus     ( ExitStatus, exitVal )
import MonadIO.Process.MakeProc       ( MakeProc, makeProc )
import MonadIO.Process.OutputHandles  ( OutputHandles )
import MonadIO.Process.Pid            ( Pid( Pid ) )
import MonadIO.Process.ToMaybeTexts   ( ToMaybeTexts )

-- mtl ---------------------------------

import Control.Monad.Reader  ( MonadReader, asks )

-- safe --------------------------------

import Safe  ( succSafe )

------------------------------------------------------------
--                     local imports                      --
------------------------------------------------------------

import MockIO.Process.CmdRW          ( CmdRW( CmdR, CmdW ), ioc )
import MockIO.Process.MLCmdSpec      ( HasMLCmdSpec( cmdspec, cmdrw, mock
                                                   , mock_value, severity )
                                     , ToCmdSpec( toCmdSpec )
                                     , ToMLCmdSpec( toMLCmdSpec )
                                     )
import MockIO.Process.MLMakeIStream  ( MLMakeIStream( makeIStream ) )
import MockIO.Process.OutputDefault  ( OutputDefault )

--------------------------------------------------------------------------------

{- | Execute an external process, wait for termination, return exit status and
     whichever of stderr/stdout were implicitly requested by the return type. -}
system' ‚à∑ ‚àÄ Œµ Œ∂ Œæ œÉ œâ œá Œº .
          (MonadIO Œº, ToCmdSpec œá, HasCallStack,
           AsIOError Œµ, AsFPathError Œµ, AsCreateProcError Œµ, AsProcExitError Œµ,
           Printable Œµ, MonadError Œµ Œº, HasCallStack,
           ToMaybeTexts Œæ, OutputHandles Œ∂ Œæ, MakeProc Œ∂, MLMakeIStream œÉ,
           HasDoMock œâ, HasIOClass œâ, Default œâ, MonadLog (Log œâ) Œº) ‚áí
          Severity        -- ^ Severity at which to log action
        ‚Üí CmdRW           -- ^ Whether this is an 'active' or 'passive' command
        ‚Üí (ExitStatus, Œæ) -- ^ Dummy return values for when mocked
        ‚Üí œÉ               -- ^ stdin specification
        ‚Üí œá               -- ^ cmd + args
        ‚Üí DoMock          -- ^ whether to mock this invocation
        ‚Üí Œº (ExitInfo, Œæ)

system' sev rw (mck_estat,mck_res) inh cspec mck =
  systemx' sev rw (mck_estat,mck_res) inh cspec mck ‚â´ throwExit

--------------------

{- | `system'`, with `œâ` specialized to `MockIOClass`. -}
system ‚à∑ ‚àÄ Œµ Œ∂ Œæ œÉ œá Œº .
         (MonadIO Œº, ToCmdSpec œá, HasCallStack,
          AsIOError Œµ, AsFPathError Œµ, AsCreateProcError Œµ, AsProcExitError Œµ,
          Printable Œµ, MonadError Œµ Œº, HasCallStack,
          ToMaybeTexts Œæ, OutputHandles Œ∂ Œæ, MakeProc Œ∂, MLMakeIStream œÉ,
          MonadLog (Log MockIOClass) Œº) ‚áí
         Severity        -- ^ Severity at which to log action
       ‚Üí CmdRW           -- ^ Whether this is an 'active' or 'passive' command
       ‚Üí (ExitStatus, Œæ) -- ^ Dummy return values for when mocked
       ‚Üí œÉ               -- ^ stdin specification
       ‚Üí œá               -- ^ cmd + args
       ‚Üí DoMock          -- ^ whether to mock this invocation
       ‚Üí Œº (ExitInfo, Œæ)
system = system'

----------------------------------------

{- | Like `system`, but does not throw on any process exit/signal. -}
systemx' ‚à∑ ‚àÄ Œµ Œ∂ Œæ œÉ œâ œá Œº .
           (MonadIO Œº, ToCmdSpec œá, HasCallStack,
            AsIOError Œµ, AsFPathError Œµ, AsCreateProcError Œµ, AsProcExitError Œµ,
            Printable Œµ, MonadError Œµ Œº, HasCallStack,
            ToMaybeTexts Œæ, OutputHandles Œ∂ Œæ, MakeProc Œ∂, MLMakeIStream œÉ,
            HasDoMock œâ, HasIOClass œâ, Default œâ, MonadLog (Log œâ) Œº) ‚áí
           Severity        -- ^ Severity at which to log action
         ‚Üí CmdRW           -- ^ Whether this is an 'active' or 'passive' command
         ‚Üí (ExitStatus, Œæ) -- ^ Dummy return values for when mocked
         ‚Üí œÉ               -- ^ stdin specification
         ‚Üí œá               -- ^ cmd + args
         ‚Üí DoMock          -- ^ whether to mock this invocation
         ‚Üí Œº (ExitInfo, Œæ)

systemx' sev rw (mck_estat, mck_res) inh cspec mck = do
  inh'                     ‚Üê makeIStream sev inh mck
  (cmd_spec, env_mod_msgs) ‚Üê toCmdSpec cspec
  let mck_val       = (exitInfo mck_estat cmd_spec (Pid 0), mck_res)
      io_class      = def & ioClass ‚ä¢ (ioc rw) & doMock ‚ä¢ mck
      pp            ‚à∑ ùïã ‚Üí ùïã
      pp t          = if mck ‚â° DoMock then "(" ‚äï t ‚äï ")" else t
      penv ‚à∑ (MonadIO ŒΩ ,MonadLog (Log œâ) ŒΩ) ‚áí Pid ‚Üí CmdSpec ‚Üí ŒΩ ()
      penv p c    = do
        logIO sev io_class $ pp $ [fmt|<CMD> ¬´%w¬ª %T|] p cmd_spec
        e ‚Üê (flip fromMaybe (c ‚ä£ env)) ‚ä≥ getEnvironment
        forM_ env_mod_msgs $ \ t ‚Üí
          logIO (succSafe sev) io_class $ pp $ [fmt|<ENVMOD> ¬´%w¬ª %t|] p t
        forM_ (sortOn fst $ toList e) $ \ (ek,ev) ‚Üí
          logIO (succSafe $ succSafe sev) io_class $
            pp $ [fmt|<ENV> ¬´%w¬ª %q ‚Üí %q|] p ek ev

  (result,p) ‚Üê if DoMock ‚â° mck
               then do penv (Pid 0) cmd_spec
                       return (mck_val, Pid 0)
               else do (procH, w) ‚Üê makeProc inh' cmd_spec
                       p ‚Üê getPid' procH
                       penv p cmd_spec
                       (,p) ‚ä≥ procWait cmd_spec (return (procH, w))

  let msg          = [fmtT|<CMD> ¬´%w¬ª %T|] p cmd_spec
      msgR         ‚à∑ (ExitInfo, Œæ) ‚Üí [ùïã]
      msgR (ex, _) = [[fmtT|exit: %T|] (ex ‚ä£ exitVal)]
  logResult sev io_class mck msg (ùïµ msgR) (ùïΩ result)

--------------------

{- | `systemx`, with `œâ` specialized to `MockIOClass`. -}
systemx ‚à∑ ‚àÄ Œµ Œ∂ Œæ œÉ œá Œº .
           (MonadIO Œº, ToCmdSpec œá, HasCallStack,
            AsIOError Œµ, AsFPathError Œµ, AsCreateProcError Œµ, AsProcExitError Œµ,
            Printable Œµ, MonadError Œµ Œº, HasCallStack,
            ToMaybeTexts Œæ, OutputHandles Œ∂ Œæ, MakeProc Œ∂, MLMakeIStream œÉ,
            MonadLog (Log MockIOClass) Œº) ‚áí
           Severity        -- ^ Severity at which to log action
         ‚Üí CmdRW           -- ^ Whether this is an 'active' or 'passive' command
         ‚Üí (ExitStatus, Œæ) -- ^ Dummy return values for when mocked
         ‚Üí œÉ               -- ^ stdin specification
         ‚Üí œá               -- ^ cmd + args
         ‚Üí DoMock          -- ^ whether to mock this invocation
         ‚Üí Œº (ExitInfo, Œæ)

systemx = systemx'

{-
Œª> :m + Control.Monad.Log MonadIO.Process.ExitStatus FPath.AbsFile
        MockIO.OpenFile MonadIO.Process.CmdSpec MockIO MonadError Data.Function
        MonadIO.Error.CreateProcError Data.Either MockIO.Log
Œª> let cspec = mkCmd [absfile|/run/current-system/sw/bin/grep|]
                     ["martyn","/etc/group"]
Œª> logit' $ splitMError @ProcError @_ @(Either _)
          $ system Notice CmdR (ExitVal 0, ()) [absfile|/dev/null|] cspec NoMock
-}

{- | Like `system`, but collects all of the cmd specification (including mock /
     log bits) into MLCmdSpec.

     Œµ - error type
     Œ± - type of input to be converted to an MLCmdSpec (e.g., (AbsFile,[ùïã]))
     Œæ - type of output (e.g., () or [ùïã])
     œâ - logging class
     Œ∂ - type of output handles (inferred from Œæ)
     œÉ - type of input (e.g., ‚Ñç, or File, or [ùïã])
     Œº - encompassing Monad
 -}
sys' ‚à∑ ‚àÄ Œµ Œ± Œæ œâ Œ∂ œÉ Œº .
      (MonadIO Œº, HasCallStack,
       ToMLCmdSpec Œ± Œæ, OutputDefault Œæ, ToMaybeTexts Œæ,
       OutputHandles Œ∂ Œæ, MakeProc Œ∂,
       AsIOError Œµ, AsFPathError Œµ, AsCreateProcError Œµ,
       AsProcExitError Œµ, Printable Œµ, MonadError Œµ Œº,
       MLMakeIStream œÉ,
       Default œâ, HasIOClass œâ, HasDoMock œâ, MonadLog (Log œâ) Œº) ‚áí
      œÉ ‚Üí Œ± ‚Üí Œº (ExitInfo, Œæ)

sys' inh proto_mlc = do
  (mlc,msgs) ‚Üê toMLCmdSpec proto_mlc
  system' (mlc ‚ä£ severity) (mlc ‚ä£ cmdrw) (mlc ‚ä£ mock_value) inh
                           (mlc ‚ä£ cmdspec, msgs) (mlc ‚ä£ mock)

----------------------------------------

{- | Like `sys'`, but hardens the log class to `MockIOClass`, and pull the
     mock value from a surrounding Reader.

     N.B.: the mock value from the reader will override any set in the
           (inferred) MLCmdSpec.
-}
sys ‚à∑ ‚àÄ Œµ Œ¥ Œ± Œæ Œ∂ œÉ Œº .
      (MonadIO Œº, HasCallStack, HasDoMock Œ¥, MonadReader Œ¥ Œº,
       ToMLCmdSpec Œ± Œæ, OutputDefault Œæ, ToMaybeTexts Œæ,
       OutputHandles Œ∂ Œæ, MakeProc Œ∂,
       AsIOError Œµ, AsFPathError Œµ, AsCreateProcError Œµ,
       AsProcExitError Œµ, Printable Œµ, MonadError Œµ Œº,
       MLMakeIStream œÉ, MonadLog (Log MockIOClass) Œº) ‚áí
      œÉ ‚Üí Œ± ‚Üí Œº (ExitInfo, Œæ)

sys inh proto_mlc = do
  mck        ‚Üê asks (view doMock)
  (mlc,msgs) ‚Üê toMLCmdSpec proto_mlc
  system' (mlc ‚ä£ severity) (mlc ‚ä£ cmdrw) (mlc ‚ä£ mock_value) inh
                           (mlc ‚ä£ cmdspec, msgs) mck

--------------------

{- | Alias for `sys` -}
(¬°) ‚à∑ ‚àÄ Œµ Œ¥ Œ± Œæ Œ∂ œÉ Œº .
      (MonadIO Œº, HasCallStack, HasDoMock Œ¥, MonadReader Œ¥ Œº,
       ToMLCmdSpec Œ± Œæ, OutputDefault Œæ, ToMaybeTexts Œæ,
       OutputHandles Œ∂ Œæ, MakeProc Œ∂,
       AsIOError Œµ, AsFPathError Œµ, AsCreateProcError Œµ,
       AsProcExitError Œµ, Printable Œµ, MonadError Œµ Œº,
       MLMakeIStream œÉ, MonadLog (Log MockIOClass) Œº) ‚áí
      œÉ ‚Üí Œ± ‚Üí Œº (ExitInfo, Œæ)

(¬°) = sys

----------------------------------------

{-| Like `sys`, but implicitly takes `/dev/null` for input. -}

sysN ‚à∑ ‚àÄ Œµ Œ¥ Œ± Œæ Œ∂ Œº .
       (MonadIO Œº, HasCallStack, HasDoMock Œ¥, MonadReader Œ¥ Œº,
        ToMLCmdSpec Œ± Œæ, OutputDefault Œæ, ToMaybeTexts Œæ,
        OutputHandles Œ∂ Œæ, MakeProc Œ∂,
        AsIOError Œµ, AsFPathError Œµ, AsCreateProcError Œµ,
        AsProcExitError Œµ, Printable Œµ, MonadError Œµ Œº,
        MonadLog (Log MockIOClass) Œº) ‚áí
       Œ± ‚Üí Œº (ExitInfo, Œæ)
sysN c = devnull ‚â´ flip sys c

----------

{-| Alias for `sysN` -}
Íô© ‚à∑ ‚àÄ Œµ Œ¥ Œ± Œæ Œ∂ Œº .
    (MonadIO Œº, HasCallStack, HasDoMock Œ¥, MonadReader Œ¥ Œº,
     ToMLCmdSpec Œ± Œæ, OutputDefault Œæ, ToMaybeTexts Œæ,
     OutputHandles Œ∂ Œæ, MakeProc Œ∂,
     AsIOError Œµ, AsFPathError Œµ, AsCreateProcError Œµ,
     AsProcExitError Œµ, Printable Œµ, MonadError Œµ Œº,
     MonadLog (Log MockIOClass) Œº) ‚áí
    Œ± ‚Üí Œº (ExitInfo, Œæ)
Íô© = sysN

----------------------------------------

{-| Like `sys`, but implicitly takes `/dev/stdin` for input. -}
sysS ‚à∑ ‚àÄ Œµ Œ¥ Œ± Œæ Œ∂ Œº .
       (MonadIO Œº, HasCallStack, HasDoMock Œ¥, MonadReader Œ¥ Œº,
        ToMLCmdSpec Œ± Œæ, OutputDefault Œæ, ToMaybeTexts Œæ,
        OutputHandles Œ∂ Œæ, MakeProc Œ∂,
        AsIOError Œµ, AsFPathError Œµ, AsCreateProcError Œµ,
        AsProcExitError Œµ, Printable Œµ, MonadError Œµ Œº,
        MonadLog (Log MockIOClass) Œº) ‚áí
       Œ± ‚Üí Œº (ExitInfo, Œæ)
sysS = sys stdin

----------

{-| Alias for `sysS` -}
Íô´ ‚à∑ ‚àÄ Œµ Œ¥ Œ± Œæ Œ∂ Œº .
    (MonadIO Œº, HasCallStack, HasDoMock Œ¥, MonadReader Œ¥ Œº,
     ToMLCmdSpec Œ± Œæ, OutputDefault Œæ, ToMaybeTexts Œæ,
     OutputHandles Œ∂ Œæ, MakeProc Œ∂,
     AsIOError Œµ, AsFPathError Œµ, AsCreateProcError Œµ,
     AsProcExitError Œµ, Printable Œµ, MonadError Œµ Œº,
     MonadLog (Log MockIOClass) Œº) ‚áí
    Œ± ‚Üí Œº (ExitInfo, Œæ)
Íô´ = sysS

{-

Œª> :m + FPath.AbsFile MonadIO.Error.CreateProcError Data.Either Data.Text
        Control.Monad.Log MockIO MonadError Data.Function MockIO.Log

Œª> let mlc = mkMLCmd Notice CmdR [absfile|/run/current-system/sw/bin/grep|]
                                 ["martyn","/etc/group"] NoMock

Œª> logit' $ splitMError @ProcError @_ @(Either _)
          $ sys @_ @_ @Text [absfile|/dev/null|] mlc

------------------------------------------------------------

Œª> :m + FPath.AbsFile MonadIO.Error.CreateProcError Data.Either Data.Text
        Control.Monad.Log MockIO MonadError Data.Function MockIO.Log
        MockIO.Process.MLCmdSpec MonadIO.Process.CmdSpec ContainersPlus.Insert

Œª> let mlc = mkMLCmdR [absfile|/run/current-system/sw/bin/grep|]
                      ["martyn","/etc/group"] NoMock & expExitVal <& 1

Œª> Right (Right (ev,(t::Text))) <- logit' $ splitMError @ProcError @(Either _)
                                          $ [absfile|/dev/null|] ! mlc

Œª> Data.Text.IO.putStrLn t

-}

{- | Alias for `sys` -}
{-
(!) ‚à∑ ‚àÄ Œµ Œ∂ Œæ œÉ Œº .
      (MonadIO Œº,
       AsIOError Œµ, AsFPathError Œµ, AsCreateProcError Œµ, AsProcExitError Œµ,
       Printable Œµ, MonadError Œµ Œº, HasCallStack,
       ToMaybeTexts Œæ, OutputHandles Œ∂ Œæ, MakeProc Œ∂, MLMakeIStream œÉ,
       MonadLog (Log MockIOClass) Œº) ‚áí
      œÉ ‚Üí MLCmdSpec Œæ ‚Üí Œº (ExitInfo, Œæ)
(!) = sys
-}

----------------------------------------

{- | Spawn a process; return the exit value, throw on signal.  The `finally`
     argument is always executed immediately after the process returns (whatever
     the exit value).
 -}
doProc' ‚à∑ ‚àÄ Œµ Œ∂ Œæ œÉ œâ œá Œº .
         (MonadIO Œº, HasCallStack, MLMakeIStream œÉ, ToCmdSpec œá,
          ToMaybeTexts Œæ, MakeProc Œ∂, OutputHandles Œ∂ Œæ,
          AsProcExitError Œµ, AsCreateProcError Œµ, AsFPathError Œµ, AsIOError Œµ,
          Printable Œµ, MonadError Œµ Œº, HasDoMock œâ, HasIOClass œâ, Default œâ,
          MonadLog (Log œâ) Œº) ‚áí
         Severity ‚Üí CmdRW ‚Üí Œº () ‚Üí (ExitStatus, Œæ) ‚Üí œÉ ‚Üí œá ‚Üí DoMock
       ‚Üí Œº (ExitInfo, Œæ)
doProc' sev rw finally mck_val input cspec mck = do
  result ‚Üê systemx' sev rw mck_val input cspec mck
  finally
  throwSig' (ùïΩ result)

----------------------------------------

{- | `doProc'` with `œâ` hardened to `MockIOClass`  -}
doProc ‚à∑ ‚àÄ Œµ Œ∂ Œæ œÉ œá Œº .
        (MonadIO Œº, HasCallStack, MLMakeIStream œÉ, ToCmdSpec œá,
         ToMaybeTexts Œæ, MakeProc Œ∂, OutputHandles Œ∂ Œæ,
         AsProcExitError Œµ, AsCreateProcError Œµ, AsFPathError Œµ, AsIOError Œµ,
         Printable Œµ, MonadError Œµ Œº, MonadLog (Log MockIOClass) Œº) ‚áí
        Severity ‚Üí CmdRW ‚Üí Œº () ‚Üí (ExitStatus, Œæ) ‚Üí œÉ ‚Üí œá ‚Üí DoMock
      ‚Üí Œº (ExitInfo, Œæ)

doProc = doProc'

-- that's all, folks! ----------------------------------------------------------
